use std::time::Instant;
use serde::{Deserialize, Serialize};

use controller::ControlId;
use crate::harmonic::{FretButton, ChordSpec, FretRow, WhammyDefaults, SustainDefaults};

/// Performance state tracking for chord playing behavior
#[derive(Debug, Clone)]
pub struct PerformanceState {
    /// Currently held fret button (highest priority)
    pub active_fret: Option<FretButton>,
    /// Chord spec for the active fret
    pub active_chord_spec: Option<ChordSpec>,
    /// Whether a chord is currently sustaining
    pub is_sustaining: bool,
    /// Voice handle for audio engine (if any)
    pub active_voice_handle: Option<u32>,
    /// Normalized whammy value (0.0 to 1.0)
    pub whammy_value: f32,
    /// Timestamp of last strum trigger
    pub last_strum_time: Instant,
    /// Row currently being used (main or solo)
    pub active_row: FretRow,
    /// Sustain settings
    pub sustain_config: SustainDefaults,
    /// Whammy settings
    pub whammy_config: WhammyDefaults,
}

impl Default for PerformanceState {
    fn default() -> Self {
        Self {
            active_fret: None,
            active_chord_spec: None,
            is_sustaining: false,
            active_voice_handle: None,
            whammy_value: 0.0,
            last_strum_time: Instant::now(),
            active_row: FretRow::Main,
            sustain_config: SustainDefaults::default(),
            whammy_config: WhammyDefaults::default(),
        }
    }
}

/// Events generated by the performance engine
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PerformanceEvent {
    /// Trigger a new chord
    ChordTrigger {
        fret_button: FretButton,
        chord_spec: ChordSpec,
        velocity: u8,
        row: FretRow,
    },
    /// Release the current chord
    ChordRelease {
        fade_time_ms: f32,
    },
    /// Apply whammy effect
    WhammyEffect {
        normalized_value: f32,
        pitch_bend_semitones: f32,
        vibrato_depth: f32,
        filter_cutoff: Option<f32>,
    },
    /// Stop whammy effects
    WhammyStop,
    /// Emergency stop all sounds
    Panic,
}

/// Performance engine that handles guitar controller input mapping to musical performance
#[derive(Debug)]
pub struct PerformanceEngine {
    state: PerformanceState,
    /// Fret button priority order (highest to lowest)
    fret_priority: [FretButton; 5],
    /// Last controller button states for edge detection
    last_button_states: std::collections::HashMap<ControlId, bool>,
    /// Whammy smoothing buffer
    whammy_smooth_buffer: CircularBuffer,
}

impl PerformanceEngine {
    pub fn new() -> Self {
        Self {
            state: PerformanceState::default(),
            fret_priority: [
                FretButton::Orange,  // Highest priority
                FretButton::Blue,
                FretButton::Yellow,
                FretButton::Red,
                FretButton::Green,   // Lowest priority
            ],
            last_button_states: std::collections::HashMap::new(),
            whammy_smooth_buffer: CircularBuffer::new(8),
        }
    }

    /// Process controller input and generate performance events
    pub fn process_input(
        &mut self,
        controller_state: &controller::ControllerState,
        main_chord_map: &std::collections::HashMap<FretButton, ChordSpec>,
        solo_chord_map: &std::collections::HashMap<FretButton, ChordSpec>,
    ) -> Vec<PerformanceEvent> {
        let mut events = Vec::new();

        // Determine active row based on solo frets
        let using_solo_row = self.any_solo_frets_pressed(controller_state);
        self.state.active_row = if using_solo_row {
            FretRow::Solo
        } else {
            FretRow::Main
        };

        let current_chord_map = if self.state.active_row == FretRow::Solo {
            solo_chord_map
        } else {
            main_chord_map
        };

        // Get currently pressed frets in priority order
        let pressed_fret = self.get_highest_priority_fret(controller_state);

        // Detect strum events
        let (strum_up_pressed, strum_down_pressed) = self.detect_strum_events(controller_state);
        let strum_triggered = strum_up_pressed || strum_down_pressed;

        // Handle chord triggering logic
        if strum_triggered {
            if let Some(fret) = pressed_fret {
                // Trigger new chord
                if let Some(chord_spec) = current_chord_map.get(&fret) {
                    // Stop previous chord if any
                    if self.state.is_sustaining {
                        events.push(PerformanceEvent::ChordRelease {
                            fade_time_ms: 50.0, // Quick crossfade
                        });
                    }

                    // Calculate velocity based on strum (TODO: implement strum velocity detection)
                    let velocity = 100; // Default velocity

                    // Trigger new chord
                    events.push(PerformanceEvent::ChordTrigger {
                        fret_button: fret,
                        chord_spec: chord_spec.clone(),
                        velocity,
                        row: self.state.active_row,
                    });

                    // Update state
                    self.state.active_fret = Some(fret);
                    self.state.active_chord_spec = Some(chord_spec.clone());
                    self.state.is_sustaining = self.state.sustain_config.enabled;
                    self.state.last_strum_time = Instant::now();
                }
            } else {
                // No frets pressed but strum triggered - stop current chord
                if self.state.is_sustaining {
                    events.push(PerformanceEvent::ChordRelease {
                        fade_time_ms: self.state.sustain_config.release_time_ms,
                    });
                    self.state.is_sustaining = false;
                    self.state.active_fret = None;
                    self.state.active_chord_spec = None;
                }
            }
        } else if self.state.is_sustaining {
            // Check if sustaining chord should be released
            if pressed_fret != self.state.active_fret {
                // Fret combination changed without strum - release sustain
                events.push(PerformanceEvent::ChordRelease {
                    fade_time_ms: self.state.sustain_config.release_time_ms,
                });
                self.state.is_sustaining = false;
                self.state.active_fret = None;
                self.state.active_chord_spec = None;
            }
        }

        // Handle whammy bar effects
        if self.state.is_sustaining && self.state.whammy_config.enabled {
            let whammy_events = self.process_whammy_input(controller_state);
            events.extend(whammy_events);
        }

        events
    }

    /// Detect strum up/down edge events
    fn detect_strum_events(&mut self, controller_state: &controller::ControllerState) -> (bool, bool) {
        let strum_up_current = controller_state.buttons.get(&ControlId::StrumUp).copied().unwrap_or(false);
        let strum_down_current = controller_state.buttons.get(&ControlId::StrumDown).copied().unwrap_or(false);

        let strum_up_last = self.last_button_states.get(&ControlId::StrumUp).copied().unwrap_or(false);
        let strum_down_last = self.last_button_states.get(&ControlId::StrumDown).copied().unwrap_or(false);

        self.last_button_states.insert(ControlId::StrumUp, strum_up_current);
        self.last_button_states.insert(ControlId::StrumDown, strum_down_current);

        let strum_up_pressed = strum_up_current && !strum_up_last;
        let strum_down_pressed = strum_down_current && !strum_down_last;

        (strum_up_pressed, strum_down_pressed)
    }

    /// Get the highest priority pressed fret button
    fn get_highest_priority_fret(
        &self, 
        controller_state: &controller::ControllerState
    ) -> Option<FretButton> {
        for &fret_button in &self.fret_priority {
            let control_id = match (fret_button, self.state.active_row) {
                (FretButton::Green, FretRow::Main) => ControlId::FretGreen,
                (FretButton::Red, FretRow::Main) => ControlId::FretRed,
                (FretButton::Yellow, FretRow::Main) => ControlId::FretYellow,
                (FretButton::Blue, FretRow::Main) => ControlId::FretBlue,
                (FretButton::Orange, FretRow::Main) => ControlId::FretOrange,
                (FretButton::Green, FretRow::Solo) => ControlId::SoloGreen,
                (FretButton::Red, FretRow::Solo) => ControlId::SoloRed,
                (FretButton::Yellow, FretRow::Solo) => ControlId::SoloYellow,
                (FretButton::Blue, FretRow::Solo) => ControlId::SoloBlue,
                (FretButton::Orange, FretRow::Solo) => ControlId::SoloOrange,
            };

            if controller_state.buttons.get(&control_id).copied().unwrap_or(false) {
                return Some(fret_button);
            }
        }
        None
    }

    /// Check if any solo frets are currently pressed
    fn any_solo_frets_pressed(&self, controller_state: &controller::ControllerState) -> bool {
        let solo_controls = [
            ControlId::SoloGreen,
            ControlId::SoloRed,
            ControlId::SoloYellow,
            ControlId::SoloBlue,
            ControlId::SoloOrange,
        ];

        solo_controls.iter().any(|&control| {
            controller_state.buttons.get(&control).copied().unwrap_or(false)
        })
    }

    /// Process whammy bar input and generate whammy effects
    fn process_whammy_input(
        &mut self,
        controller_state: &controller::ControllerState,
    ) -> Vec<PerformanceEvent> {
        let raw_whammy = controller_state.axis(ControlId::WhammyBar);
        
        // Normalize whammy input to 0.0 - 1.0 (handle different controller ranges)
        let normalized_whammy = if raw_whammy < 0.0 {
            // Assume -1.0 to 1.0 range, convert to 0.0 to 1.0
            (raw_whammy + 1.0) * 0.5
        } else {
            // Assume 0.0 to 1.0 range
            raw_whammy
        };

        // Apply smoothing to prevent zipper noise
        self.whammy_smooth_buffer.push(normalized_whammy);
        let smoothed_whammy = self.whammy_smooth_buffer.average();
        
        self.state.whammy_value = smoothed_whammy;

        let mut events = Vec::new();

        if smoothed_whammy > 0.01 {
            // Whammy is active
            let pitch_bend_semitones = smoothed_whammy * self.state.whammy_config.pitch_bend_range_semitones;
            let vibrato_depth = smoothed_whammy * self.state.whammy_config.vibrato_depth;
            let filter_cutoff = if self.state.whammy_config.filter_cutoff_enabled {
                Some(smoothed_whammy)
            } else {
                None
            };

            events.push(PerformanceEvent::WhammyEffect {
                normalized_value: smoothed_whammy,
                pitch_bend_semitones,
                vibrato_depth,
                filter_cutoff,
            });
        } else if self.state.whammy_value > 0.01 {
            // Whammy was active, now stopped
            events.push(PerformanceEvent::WhammyStop);
        }

        events
    }

    /// Update sustain configuration
    pub fn update_sustain_config(&mut self, config: SustainDefaults) {
        self.state.sustain_config = config;
    }

    /// Update whammy configuration
    pub fn update_whammy_config(&mut self, config: WhammyDefaults) {
        self.state.whammy_config = config;
    }

    /// Force stop all active performance
    pub fn panic(&mut self) -> Vec<PerformanceEvent> {
        self.state.is_sustaining = false;
        self.state.active_fret = None;
        self.state.active_chord_spec = None;
        self.state.active_voice_handle = None;
        self.state.whammy_value = 0.0;
        
        vec![PerformanceEvent::Panic]
    }

    /// Get current performance state
    pub fn state(&self) -> &PerformanceState {
        &self.state
    }
}

impl Default for PerformanceEngine {
    fn default() -> Self {
        Self::new()
    }
}

/// Simple circular buffer for smoothing f32 values
#[derive(Debug)]
struct CircularBuffer {
    buffer: Vec<f32>,
    index: usize,
    capacity: usize,
}

impl CircularBuffer {
    fn new(capacity: usize) -> Self {
        Self {
            buffer: vec![0.0; capacity],
            index: 0,
            capacity,
        }
    }

    fn push(&mut self, value: f32) {
        self.buffer[self.index] = value;
        self.index = (self.index + 1) % self.capacity;
    }

    fn average(&self) -> f32 {
        self.buffer.iter().sum::<f32>() / self.capacity as f32
    }
}